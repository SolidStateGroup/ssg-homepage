---
title: Prioritizing Data Design and Data Generation with Intermock
description: How is prioritizing data design and generating mock data is heping us in our development process
date: 16-feb-2023
featured: true
author: Rashila Pandey
published: true
avatar: public/images/blog/rashila.jpg
image: https://storage.googleapis.com/ssg-website-images/data-design-and-generation-intermock/digital-art.png
tags: typescipt, data-design
---

Starting a new project can be both exciting and intimidating, particularly in software development. As developers, we often rush into coding, eager to see our ideas come to life.However, in our experience, taking the time to carefully plan and design our data structures before development can save us countless hours of debugging and refactoring in the long run.

## Sprint 0

Before starting development we have a sprint 0, this allows us to plan and develop a project skeleton and infrastructure before getting into implementation detail. For us, an important part of this is data design: a formal definition of all of the API endpoints we intend on writing, specifying the data required in every request and response. etc
For each of the features defined during estimation in [Jira](https://www.atlassian.com/software/jira), between a designer, backend and frontend developer we specify any relevant endpoints required. Etc

The result of data design form sprint 0 would look something like this

<img src="https://storage.googleapis.com/ssg-website-images/data-design-and-generation-intermock/data%20design%20ticket%20jira.png"/>

## What we get

The output of data design is
- A definition against the ticket of the data required. This is an integral part of contract testing([https://docs.pact.io/](https://docs.pact.io/))
- A database diagram for backend development etc
- Code generated by our bespoke CLI tool

## What was missing

But designing data structures is just one part of the puzzle. In order to work with real data on the frontend without a bottleneck, we needed a way to generate realistic, complex data that matched our data definitions. That's where Google's [intermock](https://github.com/google/intermock) library comes in. The intermock library uses the faker tool to create dummy data based on the provided type definition. However, during our experimentation with intermock, we discovered that it had some shortcomings, such as the fact that it hadn't been updated in two years and was utilising dependencies that were four to five years old.

## How we solved this

Since there were numerous issues, we saw an opportunity to improve it, so we upgraded all of the packages to the latest versions and added missing features that we deemed essential, such as intersection type and Typescript generics support.

With these enhancements, intermock can now generate not only random data but also real data such as a dummy image URL for avatar or image, a real phone number for phone\_number, or even a past date for published\_date. We have also submitted a [pull request](https://github.com/google/intermock/pull/83) for these changes to intermock.

Let's look into an example of how we use intermock to achieve getting desired dummy data in our project:

First, we define our data structures in TypeScript. In this case, we have defined a set of interfaces in a file called "responses.ts":

``` typescript
export interface PagedResponse<T> {
 count?: number
 next?: string
 previous?: string
 results: T[]
}

export type GENDER = 'MALE' | 'FEMALE'

export type Profile = {
 first_name: string | null
 last_name: string | null
 avatar: string | null
 birthdate: string | null
 gender: GENDER | null
 id?: string
}

export type ID = {
 id: string
}

export type Comment = {
 author: Profile
 images: string[] | null
 message: string
 like_count: number
}

export type Res = {
 confirmEmail: ID
 user: Profile | null
 comments: PagedResponse<Comment>
}
```

Next, we pass in this file and the interface whose data we want to generate to a mock function provided by intermock which would return us the dummy data in json format .

``` typescript
import { readFileSync } from 'fs'
import { mock } from 'intermock-ssg'

const generateMockData = () => {
 return mock({
   files: [
     [
       './types/responses.ts',
       readFileSync('./types/responses.ts').toString(),
     ],
   ],
   interfaces: ['Res'],
   output: 'json',
 })
}
```

After getting the response from the function, we went further and created a new function that writes the response to a new file, called "mock-data.ts". This allows us to have a uniform data structure that can be shared with the team effortlessly. To make things even easier, we added a script that does all of this with a simple command, "npm run generate-mock".

Our newly generated mock-data.ts looks like this

``` typescript
import { Res } from 'common/types/responses'
export const mockData: Res = {
 'confirmEmail': { 'id': '2pg2okb8a' },
 'user': {
   'first_name': 'Tanner',
   'last_name': 'Gusikowski',
   'avatar':    'https://cloudflare-ipfs.com/ipfs/Qmd3W5DuhgHirLHGVixi6V76LhCkZUz6pnFt5AJBiyvHye/avatar/16.jpg',
   'birthdate': '2003-03-29T19:19:30.849Z',
   'gender': 'FEMALE',
 },
 'comments': {
   'count': 5,
   'next': 'https://foolish-apricot.info',
   'results': [
     {
       'author': {
         'first_name': 'Tanner',
         'last_name': 'Gusikowski',
         'avatar':       'https://cloudflare-ipfs.com/ipfs/Qmd3W5DuhgHirLHGVixi6V76LhCkZUz6pnFt5AJBiyvHye/avatar/16.jpg',
         'birthdate': '2003-03-29T19:19:30.849Z',
         'gender': 'FEMALE',
         'id': '2pg2okb8a',
       },
       'images': [
         'https://loremflickr.com/640/480',
         'https://loremflickr.com/640/480',
       ],
       'message': 'Rerum dolorum sed.',
       'like_count': 8,
     },
   ],
 },
}

   ```

## How has this benefited us

Our enhancements to intermock have been a huge time-saver for our team. We can now generate realistic dummy data with just a few lines of code, and use it to test our frontend components and UI layouts before we even have a backend in place.
Another important advantage of using intermock is that it can be utilised to generate mock data for test cases.

However, the most significant advantage of our approach is the way it helps us work more efficiently with our backend team. By defining our data structures and generating dummy data based on them, we can create an API contract that ensures everyone is on the same page. Our backend team knows exactly what data to expect from our frontend components, and we can work together more seamlessly to build a cohesive, scalable application.

To help streamline the frontend development process, we built a command-line interface (CLI) utilising [oclif](https://oclif.io/), a robust framework for building command line interface. With our CLI, we can rapidly and effortlessly create new screens/pages and write various crud actions using any state management tool the project uses. This significantly speeds up our ability to produce our first production ready app, while also saving us substantial time that would otherwise be spent writing repetitive code.

## Our peice of advice

If you're starting a new project, we highly recommend taking the time to carefully design your data structures before diving into development. And if you're using TypeScript, consider using intermock to start building a realistic frontend without waiting for the backend. You'll save time, reduce errors, and build a more efficient, collaborative team in the process.